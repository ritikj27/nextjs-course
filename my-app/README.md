## React server components

-server comp
 && in nextjs all compoents are server compoents by deafult
 && they have the ablity to run tasks like reading files or fetching data from a db.
 && howerver ,they don,t have the ability to use hooks or handle user interaction .
&& client comp
 - to create client comp,its necessary to add "use client" at the top of component file


# routing
    &&** nextjs has a file system based routing mechanism
    &&** url paths that users can access in the brower are defined by files and folder in ur codebase .


# Routing Conventions
    ** All routes must be placed inside the app folder
    ** Every file that corresponds to a route must be named page.js or page.tsx
    ** Every folder corresponds to a path segment in the browser URL


# app folder
 #page.tsx -> home page
 #folfer -> page.tsx repsent new route


# nested routes
 /blogs
 /blogs/first
 /blogs/second

# dyncamic routes
/products
/products/id
    #app folder
    #page.tsx -> home page
    #products -> page.tsx,#[id] folder ->page.tsx

    import React from 'react'

    export default function ProductDetails({params}:any) {
    return (
        <div>ProductDetails {params.productid}</div>
    )
    }


# nested dynamic routes
/product/id
/product/1/review/1


# catch-all segment
/docs/feature1/concept1
/docs/feature2/concept2
/docs/feature2/concept1
/docs/feature1/concept2

 - we can use
    #folderDocs
        #[...slug]
            -page.tsx

    ** to view without any slug (/docs) ([[...slug]])


# not found page
    ** use app>not-found.tsx file

    ** there a one notFound() are aslo there


# Private Folders
    ** A private folder indicates that it is a private implementation detail and should not be considered by the routing system
    T** he folder and all its subfolders are excluded from routing
    ** prefix the name with underscore


## Private Folders contd.
 ** For separating Ul logic from routing logic
 ** For consistently organizing internal files across a project
 ** For sorting and grouping files in code editors
 ** And finally, for avoiding potential naming conflicts with future Next.js file conventions


## Route Groups
 ** Allows us to logically group our routes and project files without affecting the URL path structure
** Let's implement authentication routes
    Register
    Login
    Forgot password
 ## one options we make auth folder

    #auth
        #login
        #register
        #forgetPwd

## second options we make (auth) folder

    #(auth) using parenthis
        #login
        #register
        #forgetPwd


## Layouts
   **  A page is UI that is unique to a route
   **  A layout is Ul that is shared between multiple pages in the app


## How to Create Layouts
    You can define a layout by default exporting a React component from a layout.js or layout.tsx file

    That component should accept a children prop that will be populated with a child page during rendering

## Routing Metadata
    Ensuring proper search engine optimization (SEO) is crucial for increasing visibility and attracting users

    Next.js introduced the Metadata API which allows you to define metadata for each page

    Metadata ensures accurate and relevant information is displayed when your pages are shared or indexed


## Configuring Metadata
    Export a static metadata object
    Export a dynamic generate Metadata function
 ## Metadata rules
    Both layout.tsx and page.tsx files can export metadata. If defined in a layout, it applies to all pages in that layout, but if defined in a page, it applies only to that page

    Metadata is read in order, from the root level down to the final page level
    When there's metadata in multiple places for the same route, they get combined, but page metadata will replace layout metadata if they have the same properties

# title metadata
    root layout
    export const metadata:Metadata = {
        title:{
            default:"Nextjs",
            template:"%s | Coder"
        },
        description: 'Generated by Next.js',
    }
    child layout

    export const metadata:Metadata ={
        title:"Blog apge"
    }

    output title of blog page will be blog page | coder

## using absoulte properties
    export const metadata:Metadata ={
        title:{
            absolute:"Blog !!!"
        }
    }
    output will be Blog !!! (it will overwrite root title in blog page)


## nAVIGATION

    Navigation
    ** File based routing
    ** We manually entered the URLs in the browser's address bar to navigate to the different routes
    ** Users rely on Ul elements like links to navigate Clicking on them or
    Through programmatic navigation after completing an action


## Link Component Navigation
    To enable client-side navigation Next.js provides us with the Link component
    The <Link> component is a React component that extends the HTML `<a> element, and it's the primary way to navigate between routes in Next.js
    To use it, we need to import it from "next/link".


# Active navigation
    we have to use const pathName = pathName();
    const isActive = pathNAme.startsWith(nav.href)


#  Programmatically navigate
    import { useRouter } from "next/navigation";

    const router = useRouter();
        router.push("/");
        router.back();
        router.forward();
        router.replace('/');


# Templates
    Templates are similar to layouts in that they wrap each child layout or page
    But, with templates, when a user navigates between routes that share a template, a new instance of the component is mounted, DOM elements are recreated, state is not preserved, and effects are re-synchronized
    A template can be defined by exporting a default React component from a template.js or template.tsx file
    Similar to layouts, templates also should accept a children prop which will render the nested segments in the route.

# loading.tsx
* This file allows us to create loading states that are displayed to users while a specific route segment's content is loading
* The loading state appears immediately upon navigation, giving users the assurance that the application is responsive and actively loading content


# loading.tsx Benefits
1. You can display the loading state as soon as a user navigates to a new route
The immediate feedback reassures users that their action has been acknowledged, reduces perceived loading times, and makes the application feel more responsive.
2. Next.js allows the creation of shared layouts that remain interactive while new route segments are loading
Users can continue interacting with certain parts of the application, such as a navigation menu or sidebar, even if the main content is still being fetched
SL


# error.tsx
1. Automatically wrap a route segment and its nested children in a React Error Boundary
2. Create error Ul tailored to specific segments using the file-system hierarchy to adjust granularity
3. Isolate errors to affected segments while keeping the rest of the application functional
4. Add functionality to attempt to recover from an error without a full page reload


# recovering error handle
    "use client";

    import React from "react";

    export default function ErrorBoundary({
    error,
    reset,
    }: {
    error: Error;
    reset: () => void;
    }) {
    return (
        <div>
        {error.message}
        <div>
            <button onClick={reset}>Try again!!</button>
        </div>
        </div>
    );
    }


# Handling Errors in Nested Routes
* Errors bubble up to the closest parent error boundary
* An error.tsx file will cater to errors for all its nested child segments
* By positioning error.tsx files at different levels in the nested folders of a route, you can achieve a more granular level of error handling


# Handling Errors in Layouts
* An error.tsx file will handle errors for all its nested child segments
* The error boundary does not catch errors thrown here because it's nested inside the layouts component


# Parallel Routes
* Parallel routes are an advanced routing mechanism that allows for the simultaneous rendering of multiple pages within the same layout


# Parallel Routes contd.
* Parallel routes in Next.js are defined using a feature known as slots
* Slots help structure our content in a modular fashion
* To define a slot, we use the @folder naming convention
* Each slot is then passed as a prop to its corresponding 'layout.tsx' file.

dashboard
->header
    user
    notification
    matrix
->footer

-> app
    ->dasboard
        -@user
            page.tsx
        -@notification
            page.tsx
        -@matrix
            page.tsx


# Parallel Routes Benefits
* A clear benefit of parallel routes is their ability to split a single layout into various slots, making the code more manageable
* Independent route handling


# Sub-navigation in routes
Each slot of your dashboard can essentially function as a mini-application, complete with its own navigation and state management
This is especially useful in a complex application such as our dashboard where different sections serve distinct purposes.


# Unmatched Routes
* Navigation from the Ul
* In the case of navigation within the UI, Next.js retains the previously active state of a slot regardless of changes in the URL.
* Page reload

* Next.js immediately searches for a default.tsx file within each unmatched slot
The presence of this file is critical, as it provides the default content that Next.js will render in the user interface
* If this default.tsx file is missing in any of the unmatched slots for the current route Next.js will render a 404 error.


# Intercepting Routes
Intercepting routes allow you to intercept or stop the default routing behaviour to present an alternate view or component when navigating through the UI, while still preserving the intended route for scenarios like page reloads
This can be useful if you want to show a route while keeping the context of the current page


exmple
=>dashboard on local3000 and it has login button
=>when user click on login button it will open model with local3000/login
=>it aslo shareable


exmple
=>phtos app on local3000/phtos and it has click button
=>when user click on view button it will open model with local3000/phtos/[id]
=>it aslo shareable


# Intercepting Routes Conventions
(.) to match segments on the same level
(..) to match segments one level above
(..)(..) to match segments two levels above
(...) to match segments from the root app directory


# Route Handlers
1) We've learnt how to route to pages
2) We can also create custom request handlers for our routes using a feature called route handlers
3) Unlike page routes, which respond with HTML content, route handlers allow you to create RESTful endpoints, giving you full control over the response
4) There is no overhead of having to create and configure a separate server
5) Route handlers are also great for making external API requests
6) Route handlers run server-side, ensuring that sensitive information like private keys remains secure and never gets shipped to the browser


## Middleware
* Middleware in Next.js is a powerful feature that offers a robust way to intercept and control the flow of requests and responses within your applications
* It does this at a global level significantly enhancing features like redirection, URL rewrites, authentication, headers and cookies management, and more.


* Middleware allows us to specify paths where it will be active
 - Custom matcher config
 - Conditional statements.
